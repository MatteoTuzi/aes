/***************************************************************
 * Lab 2 – UART Microserver (Histogram Equalization)
 * Author: Lello Molinario
 * University of Cagliari – Advanced Embedded Systems (AES)
 ***************************************************************/

#include <stdio.h>
#include <stdlib.h>  // Necessario per malloc/free
#include "platform.h"
#include "xil_printf.h"
#include "xuartps.h"

// Base address di PS UART1
#define UART_BASE XPAR_PS7_UART_1_BASEADDR

/***************************************************************
 * read_line()
 ***************************************************************/
int read_line(char *buf, int maxlen) {
    int i = 0;
    char c;
    while (i < maxlen - 1) {
        c = XUartPs_RecvByte(UART_BASE);
        buf[i++] = c;
        if (c == '\n') break;
    }
    buf[i] = 0;
    return i;
}

/***************************************************************
 * to_int()
 ***************************************************************/
int to_int(char *s) {
    int n = 0, i = 0;
    while (s[i] >= '0' && s[i] <= '9') {
        n = n * 10 + (s[i] - '0');
        i++;
    }
    return n;
}

/***************************************************************
 * apply_histogram_equalization()
 ***************************************************************/
void apply_histogram_equalization(u8 *img, int n) {
    int hist[256] = {0};
    int cdf[256]  = {0};
    u8  map[256];

    // 1) Istogramma
    for (int i = 0; i < n; i++)
        hist[img[i]]++;

    // 2) Cumulative Distribution Function (CDF)
    cdf[0] = hist[0];
    for (int i = 1; i < 256; i++)
        cdf[i] = cdf[i - 1] + hist[i];

    // 3) Trova cdf_min (il primo valore non nullo)
    int cdf_min = 0;
    for (int i = 0; i < 256; i++) {
        if (cdf[i] != 0) {
            cdf_min = cdf[i];
            break;
        }
    }

    if (cdf_min == n) return; // Immagine a colore unico

    // 4) Costruzione Look-Up Table (LUT)
    for (int i = 0; i < 256; i++) {
        float norm = (float)(cdf[i] - cdf_min) / (float)(n - cdf_min);
        int val = (int)(norm * 255.0f + 0.5f); // Aggiunto 0.5f per l'arrotondamento (round)

        if (val < 0)   val = 0;
        if (val > 255) val = 255;

        map[i] = (u8)val;
    }

    // 5) Applicazione LUT a ogni pixel
    for (int i = 0; i < n; i++)
        img[i] = map[img[i]];
}

/***************************************************************
 * main()
 ***************************************************************/
int main() {
    init_platform();

    // Inizializzazione UART1
    XUartPs Uart_1_PS;
    XUartPs_Config *Config_1 = XUartPs_LookupConfig(XPAR_PS7_UART_1_DEVICE_ID);
    if (NULL == Config_1) return XST_FAILURE;

    XUartPs_CfgInitialize(&Uart_1_PS, Config_1, Config_1->BaseAddress);
    XUartPs_SetBaudRate(&Uart_1_PS, 115200);

    // Lettura Header PPM
    char line1[32], line2[32], line3[32];
    read_line(line1, 32);
    read_line(line2, 32);
    read_line(line3, 32);

    // Parsing Width/Height
    int width = 0, height = 0, i = 0;
    while (line2[i] >= '0' && line2[i] <= '9') width = width * 10 + (line2[i++] - '0');
    i++; // Skip space
    while (line2[i] >= '0' && line2[i] <= '9') height = height * 10 + (line2[i++] - '0');

    int num_pixels = width * height * 3;

    // Allocazione buffer con controllo sicurezza
    u8 *image = malloc(num_pixels);
    if (image == NULL) {
        cleanup_platform();
        return XST_FAILURE;
    }

    // Ricezione Dati
    for (int j = 0; j < num_pixels; j++)
        image[j] = XUartPs_RecvByte(UART_BASE);

    // Elaborazione
    apply_histogram_equalization(image, num_pixels);

    // Invio Header originale
    for (int j = 0; line1[j] != 0; j++) XUartPs_SendByte(UART_BASE, line1[j]);
    for (int j = 0; line2[j] != 0; j++) XUartPs_SendByte(UART_BASE, line2[j]);
    for (int j = 0; line3[j] != 0; j++) XUartPs_SendByte(UART_BASE, line3[j]);

    // Invio Immagine Elaborata
    for (int j = 0; j < num_pixels; j++)
        XUartPs_SendByte(UART_BASE, image[j]);

    free(image);
    cleanup_platform();
    return 0;
}
